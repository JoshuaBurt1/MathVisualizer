<!DOCTYPE html>
<html>
<head>
    <title>Math Visualizer</title>
    <style>
        body { background: #050505; color: #eee; font-family: 'Courier New', monospace; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        canvas { border: 1px solid #333; background: radial-gradient(circle, #111 0%, #000 100%); }
        .controls { background: #111; padding: 20px; border-radius: 12px; margin-bottom: 10px; border: 1px solid #333; width: 950px; display: flex; justify-content: space-around; align-items: center; }
        input { background: #000; color: #ff4444; border: 1px solid #444; padding: 10px; border-radius: 4px; font-size: 1.2em; width: 80px; text-align: center; }
        button { padding: 10px 20px; cursor: pointer; background: #2ecc71; border: none; color: #000; font-weight: bold; border-radius: 4px; }
        select { padding: 8px; background: #000; color: #fff; border: 1px solid #444; border-radius: 4px; cursor: pointer; }
        .stats { color: #2ecc71; font-size: 0.8em; line-height: 1.4; width: 300px; }
        .legend { font-size: 0.7em; color: #888; margin-top: 5px; }
        label { font-size: 0.8em; color: #aaa; text-transform: uppercase; }
    </style>
</head>

<body>

    <h1 style="color: #2ecc71; margin-top: 0;">Math Visualizer</h1>
    
    <div class="controls">
        <div>
            <label>p exponent: </label><br>
            <input type="text" id="pInput" value="11" style="margin-top:5px;">
            <button onclick="plotResonance()">PLOT DATA</button>
            <div class="legend">
                <span style="color:#ff4444">■ M # (Red)</span> | 
                <span style="color:#2ecc71">■ Factors (Green)</span>
            </div>
        </div>

        <div>
            <label>Plot Geometry:</label><br>
            <audio id="shinySound" src="{{ url_for('static', filename='shiny.mp3') }}"></audio>            
            <select id="plotType" oninput="playIfShiny(this)" onchange="plotResonance()" style="margin-top:5px;">
                <option value="ulam">Ulam Spiral (Central)</option>
                <option value="serpentine">Serpentine Square</option>
                <option value="shell">Shell Square ✨</option>
                <option value="hexagon">Centered Hexagon ✨</option>
                <option value="mod12">Mod 12 Polygon ✨</option>
            </select>
        </div>

        <div>
            <label>Zoom Context:</label><br>
            <select id="zoomMode" onchange="plotResonance()" style="margin-top:5px;">
                <option value="Factors">Factor Scale (Detailed View)</option>
                <option value="M #">Full Scale (Show M # Location)</option>
            </select>
        </div>

        <div id="statsDisplay" class="stats">Loading JSON data...</div>
    </div>

    <canvas id="spiralCanvas"></canvas>

<script id="mersenne-data" type="application/json">
    {{ data|tojson|safe }}
</script>

<script>
const dataElement = document.getElementById('mersenne-data');
const visualData = JSON.parse(dataElement.textContent);

console.log("Success! Data loaded:", visualData);

console.log("Data loaded from Flask:", visualData);

function playIfShiny(selectElement) {
    const selectedOption = selectElement.options[selectElement.selectedIndex];
    const selectedText = selectedOption.text;

    if (selectedText.includes('✨')) {
        const sfx = document.getElementById('shinySound');
        console.log("Playing Shiny SFX...");
        
        sfx.currentTime = 0;
        sfx.play().catch(e => {
            console.warn("Audio blocked: You must click the page once first to 'unlock' sound.");
        });
    }
}

function bigIntSqrt(value) {
    if (value < 2n) return value;
    let x = value / 2n + 1n;
    let y = (x + value / x) / 2n;
    while (y < x) { x = y; y = (x + value / x) / 2n; }
    return x;
}

function getSerpentineCoords(n) {
    let r = bigIntSqrt(n - 1n);
    let rem = n - (r * r);
    if (r % 2n === 0n) {
        if (rem <= r + 1n) return { x: rem - 1n, y: r };
        else return { x: r, y: r - (rem - (r + 1n)) };
    } else {
        if (rem <= r + 1n) return { x: r, y: rem - 1n };
        else return { x: r - (rem - (r + 1n)), y: r };
    }
}

function getShellCoords(n) {
    if (n === 1n) return { x: 0n, y: 0n };
    let k = bigIntSqrt(n - 1n); 
    let squareBase = k * k;
    let offset = n - squareBase;
    let shellIndex = k;
    if (offset <= shellIndex + 1n) {
        return { x: shellIndex, y: offset - 1n };
    } else {
        let leftProgress = offset - (shellIndex + 1n);
        return { x: shellIndex - leftProgress, y: shellIndex };
    }
}

function getSpiralCoordsBigInt(n) {
    if (n === 0n) return { x: 0n, y: 0n };
    let k = (bigIntSqrt(n - 1n) + 1n) / 2n;
    let t = 2n * k + 1n;
    let m = t * t;
    t = t - 1n;
    if (n >= m - t) return { x: k - (m - n), y: k }; 
    m = m - t;
    if (n >= m - t) return { x: -k, y: k - (m - n) }; 
    m = m - t;
    if (n >= m - t) return { x: -k + (m - n), y: -k }; 
    return { x: k, y: -k + (m - n - t) };         
}

function getHexCoords(n) {
    if (n === 1n) return { x: 0, y: 0 };

    let nNum = Number(n);
    // Determine which "ring" the number falls into
    // Layer k contains 6k points. Total points = 3k(k+1) + 1
    let k = 0;
    let total = 1;
    while (total < nNum) {
        k++;
        total += 6 * k;
    }

    let layer = k;
    let firstInLayer = 3 * (layer - 1) * layer + 2;
    let offset = nNum - firstInLayer;

    // Start at the top corner of the hexagon ring
    let q = 0;
    let r = -layer;

    // Hexagonal neighbor directions (moving around the ring)
    const dirs = [
        {dq: 1, dr: 0},  {dq: 0, dr: 1}, {dq: -1, dr: 1},
        {dq: -1, dr: 0}, {dq: 0, dr: -1}, {dq: 1, dr: -1}
    ];

    // Travel along the sides of the hexagon to find the specific point
    let side = Math.floor(offset / layer);
    let steps = offset % layer;

    for (let i = 0; i < side; i++) {
        q += dirs[i].dq * layer;
        r += dirs[i].dr * layer;
    }
    q += dirs[side].dq * steps;
    r += dirs[side].dr * steps;

    // Convert Axial (q, r) to Pixel (x, y)
    // The sqrt(3) constant ensures the hexagons aren't squashed
    return {
        x: (Math.sqrt(3) * q + Math.sqrt(3)/2 * r),
        y: (3/2 * r)
    };
}

// Map n to a 12-sided polygon position
function getMod12Coords(n) {
    const modValue = Number(n % 12n);
    const radius = Number(bigIntSqrt(n)); // Distance based on square root magnitude
    const angle = (modValue * 30 - 90) * (Math.PI / 180); // 30 deg increments, offset to top
    return { 
        x: radius * Math.cos(angle), 
        y: radius * Math.sin(angle),
        mod: modValue,
        radius: radius
    };
}

function plotResonance() {
    const canvas = document.getElementById('spiralCanvas');
    const ctx = canvas.getContext('2d');
    const pInput = document.getElementById('pInput').value;
    const zoomMode = document.getElementById('zoomMode').value;
    const plotType = document.getElementById('plotType').value;
    
    canvas.width = 800; canvas.height = 800;

    const isSquareGrid = (plotType === "serpentine" || plotType === "shell");
    const isCentered = (plotType === "ulam" || plotType === "mod12" || plotType === "hexagon");
    const centerX = isSquareGrid ? 40 : 400;
    const centerY = isSquareGrid ? 40 : 400;

    // Set text alignment for the background grid
    ctx.textAlign = isSquareGrid ? "left" : "center";
    ctx.textBaseline = isSquareGrid ? "top" : "middle";

    const p = BigInt(pInput);
    const pMod12 = Number(p % 12n); // Target spoke for highlighting
    const Mnum = (2n ** p) - 1n;
    const MpMod12 = Number(Mnum % 12n);
    
    const entry = visualData.find(d => d.form === `2^${pInput}-1`);
    let factors = entry ? [...new Set(entry.prime_factor.split(',').map(s => BigInt(s.trim())))] : [];

    let maxN = (zoomMode === "M #") ? Mnum : (factors.length > 0 ? factors.reduce((a, b) => a > b ? a : b) : p);
    if (p > maxN && zoomMode !== "M #") maxN = p;
    
    let baseStep = (canvas.width / 2.5) / Number(bigIntSqrt(maxN));
    let stepSize;
    if (plotType === "mod12") {
        stepSize = (canvas.width / 2.2) / Number(bigIntSqrt(maxN));
    } else if (plotType === "hexagon") {
        stepSize = (canvas.width / 2.5) / Number(bigIntSqrt(maxN));
    } else {
        stepSize = (canvas.width / 2.5) / Number(bigIntSqrt(maxN));
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // --- DRAW MOD 12 WEB WITH P-SPOKE HIGHLIGHT ---
    if (plotType === "mod12") {
        for (let i = 0; i < 12; i++) {
            const angle = (i * 30 - 90) * (Math.PI / 180);
            const isPSpoke = (i === pMod12);
            const isMpSpoke = (i === MpMod12);
            
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + 400 * Math.cos(angle), centerY + 400 * Math.sin(angle));
            
            if (isPSpoke) {
                ctx.strokeStyle = "#ffff00"; // Yellow for p spoke
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
            } else if (isMpSpoke) {
                ctx.strokeStyle = "#ff4444"; // Red for M # spoke
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
            } else {
                ctx.strokeStyle = "#1a1a1a"; // Dim for others
                ctx.lineWidth = 1;
                ctx.setLineDash([]);
            }
            ctx.stroke();
            
            // Label spokes
            ctx.fillStyle = isPSpoke ? "#ffff00" : (isMpSpoke ? "#ff4444" : "#444");
            ctx.font = isPSpoke ? "bold 14px Arial" : "10px Arial";
            let label = i.toString();
            if (isPSpoke) label += " (p-spoke)";
            ctx.fillText(label, centerX + 380 * Math.cos(angle), centerY + 380 * Math.sin(angle));
        }
    }

    let getCoords;
    if (plotType === "mod12") {
        getCoords = getMod12Coords;
    } else if (plotType === "ulam") {
        getCoords = getSpiralCoordsBigInt;
    } else if (plotType === "shell") {
        getCoords = getShellCoords;
    } else if (plotType === "hexagon") {
        getCoords = getHexCoords;
    } else {
        getCoords = getSerpentineCoords;
    }
    // ORIGIN
    ctx.fillStyle = "#fff";
    ctx.font = "bold 12px Courier New";
    ctx.textAlign = "center";
    ctx.fillText("ORIGIN", centerX, centerY - 15);
    ctx.beginPath(); ctx.arc(centerX, centerY, 4, 0, Math.PI * 2); ctx.fill();
    
    // --- DRAW HEX-RING BACKGROUND ---
    if (plotType === "hexagon" && stepSize > 15) {
        ctx.save();
        ctx.strokeStyle = "#1a1a1a"; 
        ctx.lineWidth = 1;
        
        // Determine how many points to check based on zoom
        let diameter = Math.ceil(800 / stepSize) + 5;
        let limit = BigInt(3 * diameter * diameter);

        let currentShell = 0n;
        let shellStartId = 1n;

        for (let i = 1n; i <= limit; i++) {
            // Calculate the shell index 'k' for number 'i'
            // Formula: k = ceil((3 + sqrt(9 + 12(i-1))) / 6)
            let k = BigInt(Math.ceil((3 + Math.sqrt(9 + 12 * (Number(i) - 1))) / 6));
            
            let pos = getCoords(i);
            let gx = centerX + Number(pos.x) * stepSize;
            let gy = centerY + Number(pos.y) * stepSize;

            if (k !== currentShell) {
                // If we just finished a shell, close the previous loop back to its start
                if (currentShell > 1n) {
                    let sPos = getCoords(shellStartId);
                    ctx.lineTo(centerX + Number(sPos.x) * stepSize, centerY + Number(sPos.y) * stepSize);
                    ctx.stroke();
                }
                
                // Start the new shell ring
                ctx.beginPath();
                ctx.moveTo(gx, gy);
                shellStartId = i;
                currentShell = k;
            } else {
                // Continue drawing the current ring
                ctx.lineTo(gx, gy);
            }
        }
        ctx.stroke();
        ctx.restore();
    }

    // BACKGROUND GRID
    if (stepSize > 15) {
        ctx.fillStyle = "#333";
        
        // 1. Correct the alignment for centered grids
        const isCentered = (plotType === "ulam" || plotType === "mod12" || plotType === "hexagon");
        ctx.textAlign = isCentered ? "center" : "left";
        ctx.textBaseline = isCentered ? "middle" : "top";
        ctx.font = `${Math.min(stepSize * 0.35, 14)}px Courier New`;

        let diameter = Math.ceil(800 / stepSize) + 5;
        let totalPoints;
        
        if (plotType === "hexagon") {
            totalPoints = BigInt(3 * diameter * diameter); 
        } else {
            totalPoints = BigInt(diameter * diameter);
        }

        for (let i = 1n; i <= totalPoints; i++) {
            let pos = getCoords(i);
            let gx = centerX + Number(pos.x) * stepSize;
            let gy = centerY + Number(pos.y) * stepSize;
            
            // 3. Draw if it's anywhere on the visible canvas
            if (gx >= -stepSize && gx < canvas.width + stepSize && 
                gy >= -stepSize && gy < canvas.height + stepSize) {
                ctx.fillText(i.toString(), gx, gy);
            }
        }
    }

    // Plot Markers
    plotMarker(ctx, p, stepSize, centerX, centerY, "#ffff00", `p (${p})`, 8, getCoords, canvas, plotType);
    plotMarker(ctx, Mnum, stepSize, centerX, centerY, "#ff4444", "M #", 10, getCoords, canvas, plotType);
    factors.forEach(f => {
        plotMarker(ctx, f, stepSize, centerX, centerY, "#2ecc71", f.toString(), 6, getCoords, canvas, plotType);
    });

    document.getElementById('statsDisplay').innerHTML = 
        `<span style="color:#ffff00">p: ${p} (mod12: ${pMod12})</span><br>` +
        `<span style="color:#ff4444">M # mod12: ${MpMod12}</span>`;
}

function plotMarker(ctx, n, stepSize, centerX, centerY, color, label, size, coordFn, canvas, type) {
    let coords = coordFn(n);
    let targetX = centerX + Number(coords.x) * stepSize;
    let targetY = centerY + Number(coords.y) * stepSize;

    let dx = targetX - centerX;
    let dy = targetY - centerY;
    let drawEndX = targetX;
    let drawEndY = targetY;

    const margin = 5;
    if (targetX < 0 || targetX > canvas.width || targetY < 0 || targetY > canvas.height) {
        let tValues = [];
        if (dx !== 0) {
            tValues.push((margin - centerX) / dx);
            tValues.push((canvas.width - margin - centerX) / dx);
        }
        if (dy !== 0) {
            tValues.push((margin - centerY) / dy);
            tValues.push((canvas.height - margin - centerY) / dy);
        }
        let t = Math.min(...tValues.filter(v => v > 0));
        drawEndX = centerX + dx * t;
        drawEndY = centerY + dy * t;
    }

    ctx.save();
    ctx.setLineDash([5, 5]);
    ctx.strokeStyle = color + "88";
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.lineTo(drawEndX, drawEndY);
    ctx.stroke();
    ctx.restore();

    if (targetX >= -50 && targetX <= canvas.width + 50 && targetY >= -50 && targetY <= canvas.height + 50) {
        ctx.save();
        ctx.shadowBlur = 8;
        ctx.shadowColor = color;
        ctx.fillStyle = color;
        ctx.fillRect(targetX - size/2, targetY - size/2, size, size);
        ctx.shadowBlur = 0;
        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 11px monospace";
        ctx.textAlign = "left";
        
        let info = label;
        if (type === "mod12") {
            const modVal = n % 12n;
            const radius = bigIntSqrt(n);
            info += ` (Mod12: ${modVal}, R: ${radius})`;
        }
        
        ctx.fillText(info, targetX + size, targetY + 4);
        ctx.restore();
    } else {
        ctx.fillStyle = color;
        ctx.font = "italic 10px Courier New";
        let modStr = (type === "mod12") ? ` [Mod12: ${n%12n}]` : "";
        ctx.fillText("→ " + label + modStr, drawEndX, drawEndY > canvas.height - 10 ? drawEndY - 10 : drawEndY + 10);
    }
}

plotResonance();
</script>
</body>
</html>