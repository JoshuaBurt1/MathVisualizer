<!DOCTYPE html>
<html>
<head>
    <title>Math Visualizer</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/index.css') }}">
</head>

<body>
    <h1>Math Visualizer</h1>

    <div class="controls">
        <div class="control-group">
            <label>1. Sequence Type</label>
            <select id="formulaType" onchange="plotData()">
                <option value="minus">2^p - 1 (Mersenne)</option>
                <option value="plus">2^p + 1 (Fermat)</option>
            </select>
        </div>

        <div class="control-group">
            <label>2. p Exponent</label>
            <div class="input-row">
                <input type="text" id="pInput" value="11">
                <button onclick="plotData()">PLOT</button>
            </div>
        </div>

        <div class="control-group">
            <label>3. Plot Geometry</label>
            <audio id="shinySound" src="{{ url_for('static', filename='shiny.mp3') }}"></audio>
            <select id="plotType" oninput="playIfShiny(this)" onchange="onPlotChange()">
                <option value="binary">Binary Grid</option>
                <option value="ulam">Ulam Spiral</option>
                <option value="serpentine">Serpentine Square</option>
                <option value="shell">Shell Square ✨</option>
                <option value="hexagon">Centered Hexagon ✨</option>
                <option value="mod12">Mod 12 Polygon</option>
            </select>
        </div>

        <button onclick="recenterCamera()" style="background: #444; color: #fff; margin-top: 10px;">Recenter View</button>
        <div class="legend">Click & Drag to Pan</div>
    </div>

    <canvas id="gridCanvas"></canvas>

    <div id="statsDisplay" class="stats">System Ready. Select p and Plot...</div>

    <script id="n_data" type="application/json">
        {{ data|tojson|safe }}
    </script>

<script>
/**
 * --- GLOBAL CAMERA STATE ---
 */
let markerHitBoxes = [];
let offsetX = window.innerWidth / 2;
let offsetY = window.innerHeight / 2;
let zoom = 1.0;
let isDragging = false;
let lastMouseX = 0;
let lastMouseY = 0;

const canvas = document.getElementById('gridCanvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// --- EVENT LISTENERS ---
canvas.addEventListener('mousedown', (e) => {
    isDragging = true;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
});

canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // Iterate through the hitboxes created during the last draw call
    for (const box of markerHitBoxes) {
        const dx = mouseX - box.x;
        const dy = mouseY - box.y;
        
        // Check if mouse is within the hit area (square or circular check)
        if (Math.abs(dx) < box.size && Math.abs(dy) < box.size) {
            // Found a hit! Centering camera on this BigInt value
            jumpToNumber(box.n, box.coordFn);
            return; // Stop looking after finding the topmost hit
        }
    }
});

window.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    offsetX += e.clientX - lastMouseX;
    offsetY += e.clientY - lastMouseY;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    requestAnimationFrame(plotData);
});

canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const zoomSpeed = 0.1;
    const worldX = (e.clientX - offsetX) / zoom;
    const worldY = (e.clientY - offsetY) / zoom;

    if (e.deltaY < 0) zoom *= (1 + zoomSpeed);
    else zoom /= (1 + zoomSpeed);

    zoom = Math.min(Math.max(zoom, 0.005), 500);
    offsetX = e.clientX - worldX * zoom;
    offsetY = e.clientY - worldY * zoom;
    requestAnimationFrame(plotData);
}, { passive: false });

window.addEventListener('mouseup', () => isDragging = false);
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    plotData();
});

function onPlotChange() { recenterCamera(); }

function recenterCamera() {
    const plotType = document.getElementById('plotType').value;
    zoom = 1.0; 
    if (["shell", "serpentine", "binary"].includes(plotType)) {
        offsetX = 100; offsetY = 100;
    } else {
        offsetX = window.innerWidth / 2;
        offsetY = window.innerHeight / 2;
    }
    plotData();
}

/**
 * --- MATH & COORDINATES ---
 */
const dataElement = document.getElementById('n_data');
const visualData = JSON.parse(dataElement.textContent);

function bigIntSqrt(value) {
    if (value < 2n) return value;
    let x = value / 2n + 1n;
    let y = (x + value / x) / 2n;
    while (y < x) { x = y; y = (x + value / x) / 2n; }
    return x;
}

// Fixed Binary: Grows DOWN and RIGHT
function getBinaryCoords(n) {
    const nBI = BigInt(n);
    if (nBI <= 0n) return { x: 0n, y: 0n };
    const bitString = nBI.toString(2);
    const col = BigInt(bitString.length) - 1n;
    const baseValue = 2n ** col;
    const row = nBI - baseValue;
    return { x: col, y: row };
}

function getSerpentineCoords(n) {
    let r = bigIntSqrt(n - 1n);
    let rem = n - (r * r);
    if (r % 2n === 0n) {
        if (rem <= r + 1n) return { x: rem - 1n, y: r };
        return { x: r, y: r - (rem - (r + 1n)) };
    } else {
        if (rem <= r + 1n) return { x: r, y: rem - 1n };
        return { x: r - (rem - (r + 1n)), y: r };
    }
}

function getShellCoords(n) {
    if (n === 1n) return { x: 0n, y: 0n };
    let k = bigIntSqrt(n - 1n); 
    let offset = n - (k * k);
    if (offset <= k + 1n) return { x: k, y: offset - 1n };
    return { x: k - (offset - (k + 1n)), y: k };
}

function getSpiralCoordsBigInt(n) {
    if (n === 0n) return { x: 0n, y: 0n };
    let k = (bigIntSqrt(n - 1n) + 1n) / 2n;
    let t = 2n * k + 1n;
    let m = t * t;
    t = t - 1n;
    if (n >= m - t) return { x: k - (m - n), y: k }; 
    m -= t;
    if (n >= m - t) return { x: -k, y: k - (m - n) }; 
    m -= t;
    if (n >= m - t) return { x: -k + (m - n), y: -k }; 
    return { x: k, y: -k + (m - n - t) };         
}

function getHexCoords(n) {
    let nNum = Number(n);
    if (nNum === 1) return { x: 0, y: 0 };
    
    let layer = 1, total = 1;
    while (total < nNum) { layer++; total += 6 * (layer - 1); }
    
    let prevTotal = 3 * (layer - 2) * (layer - 1) + 1;
    let offset = nNum - prevTotal - 1;
    let q = 0, r = -(layer - 1);
    
    const dirs = [
        {dq: 1, dr: 0}, {dq: 0, dr: 1}, {dq: -1, dr: 1}, 
        {dq: -1, dr: 0}, {dq: 0, dr: -1}, {dq: 1, dr: -1}
    ];
    
    let side = Math.floor(offset / (layer - 1));
    let steps = offset % (layer - 1);
    
    for (let i = 0; i < side; i++) { 
        q += dirs[i].dq * (layer - 1); 
        r += dirs[i].dr * (layer - 1); 
    }
    q += dirs[side].dq * steps; 
    r += dirs[side].dr * steps;

    // Fixed math for touching hexagons:
    // The horizontal distance between centers is sqrt(3) * radius
    // The vertical distance between centers is 1.5 * radius
    return { 
        x: (Math.sqrt(3) * q + Math.sqrt(3)/2 * r), 
        y: (1.5 * r) 
    };
}

function getMod12Coords(n) {
    const ring = Math.ceil(Number(n) / 12);
    const angle = (Number(n % 12n) * 30 - 90) * (Math.PI / 180); 
    return { x: ring * Math.cos(angle), y: ring * Math.sin(angle) };
}

/**
 * --- RENDERING ENGINE ---
 */
function plotData() {
    markerHitBoxes = []; 
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const pInput = document.getElementById('pInput').value;
    const plotType = document.getElementById('plotType').value;
    const formulaType = document.getElementById('formulaType').value; 
    const p = BigInt(pInput);
    const formulaLabel = `2^${pInput}${formulaType === "minus" ? "-1" : "+1"}`;
    
    const entry = visualData.find(d => d.form === formulaLabel || (d.p == pInput && d.type === formulaType));
    
    if (!entry) {
        document.getElementById('statsDisplay').innerHTML = `<b>Error:</b> ${formulaLabel} not found in database.`;
        return; 
    }

    const Mnum = BigInt(entry.number);
    let factors = entry.factors 
        ? entry.factors.split(',').filter(s => s.trim() !== "").map(s => BigInt(s.trim())) 
        : [];

    // --- AUTO-ZOOM LOGIC ---
    // 1. Find the highest factor <= 1000
    const nearbyFactors = factors.filter(f => f <= 1000n);
    let zoomTargetN;

    if (nearbyFactors.length > 0) {
        // If factors <= 1000 exist, zoom to the largest one among them
        zoomTargetN = nearbyFactors[nearbyFactors.length - 1];
    } else {
        // Otherwise, zoom to p
        zoomTargetN = p;
    }

    // 2. Calculate baseStepSize based on zoomTargetN
    // This ensures the target number is comfortably visible on screen
    let baseStepSize = (plotType === "binary") 
        ? (canvas.width / 40) 
        : (canvas.width / 2.5) / Number(bigIntSqrt(zoomTargetN || 1n));
    
    let finalStep = baseStepSize * zoom;

    const cfg = { ctx, p, Mnum, factors, stepSize: finalStep, canvas, centerX: offsetX, centerY: offsetY };

    // --- RENDER ---
    if (plotType === "hexagon") drawHexagonPlot(cfg);
    else if (plotType === "mod12") drawMod12Plot(cfg);
    else if (plotType === "binary") drawCommonElements(cfg, getBinaryCoords, "binary");
    else if (plotType === "ulam") drawCommonElements(cfg, getSpiralCoordsBigInt, "spiral");
    else if (plotType === "serpentine") drawCommonElements(cfg, getSerpentineCoords, "serpentine");
    else if (plotType === "shell") drawCommonElements(cfg, getShellCoords, "shell");

    updateStats(plotType, p, formulaLabel, Mnum, factors, entry);
}

function drawCommonElements(cfg, coordFn, typeTag) {
    const { ctx, stepSize, p, Mnum, factors, canvas, centerX, centerY } = cfg;
    
    // 1. Draw Background Grid
    if (stepSize > 2 && typeTag !== "hexagon" && typeTag !== "mod12") {
        ctx.save();
        ctx.strokeStyle = "#1a1a1a";
        for (let i = 1n; i <= 2000n; i++) {
            let pos = coordFn(i);
            let gx = centerX + Number(pos.x) * stepSize;
            let gy = centerY + Number(pos.y) * stepSize;
            if (gx > -stepSize && gx < canvas.width + stepSize && gy > -stepSize && gy < canvas.height + stepSize) {
                ctx.strokeRect(gx - stepSize/2, gy - stepSize/2, stepSize, stepSize);
                if (stepSize > 30) {
                    ctx.fillStyle = "#444"; ctx.textAlign = "center";
                    ctx.font = `${stepSize * 0.3}px monospace`;
                    ctx.fillText(i.toString(), gx, gy + 4);
                }
            }
        }
        ctx.restore();
    }

    // --- 2. NEW: DRAW DASHED TRACKER LINES ---
    if (typeTag !== "mod12") {
        const drawLine = (targetN, color) => {
            const startPos = coordFn(1n);
            const endPos = coordFn(targetN);
            ctx.save();
            ctx.beginPath();
            ctx.setLineDash([5, 5]); // Dashed pattern
            ctx.strokeStyle = color;
            ctx.globalAlpha = 0.4;   // Subtle transparency
            ctx.lineWidth = 2;
            ctx.moveTo(centerX + Number(startPos.x) * stepSize, centerY + Number(startPos.y) * stepSize);
            ctx.lineTo(centerX + Number(endPos.x) * stepSize, centerY + Number(endPos.y) * stepSize);
            ctx.stroke();
            ctx.restore();
        };

        // Line to Exponent (Yellow)
        drawLine(p, "#ffff00");

        // Lines to Factors (Green)
        factors.forEach(f => drawLine(f, "#00ff88"));

        // Line to Main Number (Red if Prime, Blue if Composite)
        const mColor = factors.length === 0 ? "#e74c3c" : "#3498db";
        drawLine(Mnum, mColor);
    }

    // 3. Marker Plotting Logic
    if (typeTag !== "mod12") {
        plotMarker(cfg, 1n, "#ffffff", "1", 12, coordFn, typeTag);
    }
    
    plotMarker(cfg, p, "#ffff00", `p(${p})`, 8, coordFn, typeTag); 

    if (factors.length === 0) {
        plotMarker(cfg, Mnum, "#e74c3c", `M# (Prime)`, 10, coordFn, typeTag);
    } else {
        factors.forEach(f => {
            plotMarker(cfg, f, "#00ff88", f.toString(), 6, coordFn, typeTag);
        });
        plotMarker(cfg, Mnum, "#3498db", `M# (Comp)`, 10, coordFn, typeTag);
    }
}

function drawHexPath(ctx, x, y, r) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        let angle = (Math.PI / 3) * i + (Math.PI / 6);
        ctx.lineTo(x + r * Math.cos(angle), y + r * Math.sin(angle));
    }
    ctx.closePath();
}

function drawHexagonPlot(cfg) {
    const { ctx, stepSize, canvas, centerX, centerY } = cfg;
    
    ctx.save();
    ctx.strokeStyle = "#1a1a1a";
    ctx.lineWidth = 1;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // Increase the limit to ensure the screen is filled
    const limit = 2000n; 

    for (let i = 1n; i <= limit; i++) {
        let pos = getHexCoords(i);
        let gx = centerX + pos.x * stepSize;
        let gy = centerY + pos.y * stepSize;

        // Culling for performance
        if (gx > -stepSize && gx < canvas.width + stepSize && gy > -stepSize && gy < canvas.height + stepSize) {
            
            // Draw the Hexagon Border
            // To make them touch, radius must be stepSize / sqrt(3)
            const hexRadius = stepSize;
            drawHexPath(ctx, gx, gy, hexRadius);
            ctx.stroke();

            // Number every hexagon
            if (stepSize > 30) {
                ctx.fillStyle = "#444";
                ctx.font = `${stepSize * 0.3}px monospace`;
                ctx.fillText(i.toString(), gx, gy);
            }
        }
    }
    ctx.restore();
    
    // Draw markers (1, p, factors) on top
    drawCommonElements(cfg, getHexCoords, "hexagon");
}

function drawMod12Plot(cfg) {
    const { ctx, stepSize, canvas, centerX, centerY, p, Mnum, factors } = cfg;
    const pMod = Number(p % 12n);
    const mMod = Number(Mnum % 12n);
    
    // Determine the color for the M# spoke based on JSON factors
    const mColor = factors.length === 0 ? "#3498db" : "#ff4444"; // Blue if Prime, Red if Composite

    ctx.save();
    
    // 1. Draw Concentric Rings
    const maxRings = 50; 
    for (let r = 1; r <= maxRings; r++) {
        const radius = r * stepSize;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.strokeStyle = "#1a1a1a";
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    // 2. Draw Spokes and Outlined Mod Cells
    for (let i = 0; i < 12; i++) {
        // Adjust angle: i=0 is 12 (top), i=1 is 1, etc.
        // We use (i * 30 - 90) so that 0n % 12n (which is 12) is at the top.
        const angle = (i * 30 - 90) * (Math.PI / 180);
        
        // Determine Spoke/Outline Color
        let currentColor = "#1a1a1a";
        let isHighlighted = false;
        const isFactorSpoke = factors.some(f => Number(f % 12n) === i);

        if (i === pMod) {
            currentColor = "#ffff00"; // Yellow (Exponent)
            isHighlighted = true;
        } else if (i === mMod) {
            currentColor = mColor;    // Blue/Red (M#)
            isHighlighted = true;
        } else if (isFactorSpoke) {
            currentColor = "#2ecc71"; // Green (Factor)
            isHighlighted = true;
        }

        // Draw the Spoke
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(centerX + (maxRings * stepSize) * Math.cos(angle), centerY + (maxRings * stepSize) * Math.sin(angle));
        ctx.strokeStyle = isHighlighted ? currentColor : "#1a1a1a";
        ctx.lineWidth = isHighlighted ? 3 : 1;
        ctx.stroke();

        // --- OUTLINE THE MOD VALUE CELL (INNER RING) ---
        if (isHighlighted) {
            const innerR = 0;
            const outerR = stepSize;
            const startAngle = (i * 30 - 105) * (Math.PI / 180);
            const endAngle = (i * 30 - 75) * (Math.PI / 180);

            ctx.beginPath();
            ctx.arc(centerX, centerY, outerR, startAngle, endAngle);
            ctx.lineTo(centerX + innerR * Math.cos(endAngle), centerY + innerR * Math.sin(endAngle));
            ctx.arc(centerX, centerY, innerR, endAngle, startAngle, true);
            ctx.closePath();
            
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = 4;
            ctx.stroke(); // Outline only, no fill
        }
    }

    // 3. Number the cells
    if (stepSize > 30) {
        ctx.fillStyle = "#444";
        ctx.font = `${stepSize * 0.25}px monospace`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        for (let i = 1n; i <= 200n; i++) {
            let labelRadius = (Math.ceil(Number(i) / 12) - 0.5) * stepSize;
            let angle = (Number(i % 12n) * 30 - 90) * (Math.PI / 180);
            let lx = centerX + labelRadius * Math.cos(angle);
            let ly = centerY + labelRadius * Math.sin(angle);
            
            if (lx > 0 && lx < canvas.width && ly > 0 && ly < canvas.height) {
                ctx.fillText(i.toString(), lx, ly);
            }
        }
    }
    ctx.restore();

    drawCommonElements(cfg, getMod12Coords, "mod12");
}

function plotMarker(cfg, n, color, label, size, coordFn, type, isOrigin = false) {
    const { ctx, stepSize, centerX, centerY, canvas } = cfg;
    const nBI = BigInt(n);
    const pos = coordFn(nBI);
    const tx = centerX + Number(pos.x) * stepSize;
    const ty = centerY + Number(pos.y) * stepSize;

    const margin = 20;
    const isOffScreen = tx < -stepSize || tx > canvas.width + stepSize || 
                        ty < -stepSize || ty > canvas.height + stepSize;

    const time = performance.now() / 500; 
    ctx.save();

    if (!isOffScreen) {
        // --- ON-SCREEN HITMAP ---
        markerHitBoxes.push({ n: nBI, x: tx, y: ty, size: Math.max(stepSize, 20), coordFn: coordFn });

        ctx.fillStyle = color;
        if (type === "mod12") {
            const ring = Math.ceil(Number(nBI) / 12);
            const modVal = Number(nBI % 12n);
            const innerR = (ring - 1) * stepSize;
            const outerR = ring * stepSize;
            const startAngle = (modVal * 30 - 105) * (Math.PI / 180);
            const endAngle = (modVal * 30 - 75) * (Math.PI / 180);

            ctx.beginPath();
            ctx.arc(centerX, centerY, outerR, startAngle, endAngle);
            ctx.lineTo(centerX + innerR * Math.cos(endAngle), centerY + innerR * Math.sin(endAngle));
            ctx.arc(centerX, centerY, innerR, endAngle, startAngle, true);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = "#fff";
            ctx.stroke();
        } else if (type === "hexagon") {
            drawHexPath(ctx, tx, ty, stepSize); 
            ctx.fill();
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = 1.5;
            ctx.stroke();
        } else {
            ctx.fillRect(tx - stepSize / 2, ty - stepSize / 2, stepSize, stepSize);
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = 1.5;
            ctx.strokeRect(tx - stepSize / 2, ty - stepSize / 2, stepSize, stepSize);
        }

        if (stepSize > 20) {
            ctx.fillStyle = "#000"; 
            ctx.textAlign = "center"; 
            ctx.textBaseline = "middle";
            ctx.font = `${stepSize * 0.3}px monospace`; 
            const vOff = (type === "hexagon") ? 0 : 4;
            ctx.fillText(n.toString(), tx, ty + vOff);
        }
    } else {
        // --- OFF-SCREEN TRACKING ---
        const edgeX = Math.max(margin, Math.min(canvas.width - margin, tx));
        const edgeY = Math.max(margin, Math.min(canvas.height - margin, ty));

        // --- OFF-SCREEN HITMAP ---
        // We push the edge coordinates so the radar pulses are clickable
        markerHitBoxes.push({ n: nBI, x: edgeX, y: edgeY, size: 25, coordFn: coordFn });

        const pulse = (Math.sin(time * 2) + 1) / 2;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(edgeX, edgeY, 10 + (pulse * 15), 0, Math.PI * 2);
        ctx.globalAlpha = 1 - pulse;
        ctx.stroke();

        ctx.globalAlpha = 1.0;
        ctx.shadowBlur = 15;
        ctx.shadowColor = color;
        ctx.fillStyle = color;
        ctx.beginPath(); 
        ctx.arc(edgeX, edgeY, 8, 0, Math.PI * 2); 
        ctx.fill();
        ctx.shadowBlur = 0;

        const angle = Math.atan2(ty - edgeY, tx - edgeX);
        ctx.translate(edgeX, edgeY);
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.moveTo(12, 0);
        ctx.lineTo(0, -6);
        ctx.lineTo(0, 6);
        ctx.closePath();
        ctx.fill();
        ctx.setTransform(1, 0, 0, 1, 0, 0);

        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 14px monospace";
        ctx.textAlign = tx < margin ? "left" : (tx > canvas.width - margin ? "right" : "center");
        const textOffsetX = tx < margin ? 15 : (tx > canvas.width - margin ? -15 : 0);
        const textOffsetY = ty < margin ? 25 : -20;
        const labelText = `${label}`;
        const textWidth = ctx.measureText(labelText).width;
        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.fillRect(edgeX + textOffsetX - (textWidth/2) - 5, edgeY + textOffsetY - 10, textWidth + 10, 18);
        ctx.fillStyle = color;
        ctx.fillText(labelText, edgeX + textOffsetX, edgeY + textOffsetY + 4);
    }
    ctx.restore();
}

function jumpToNumber(nBI, coordFn) {
    const plotType = document.getElementById('plotType').value;
    const pInput = document.getElementById('pInput').value;
    const formulaType = document.getElementById('formulaType').value;
    const formulaLabel = `2^${pInput}${formulaType === "minus" ? "-1" : "+1"}`;
    
    const entry = visualData.find(d => d.form === formulaLabel);
    if (!entry) return;

    const p = BigInt(pInput);
    let factors = entry.factors 
        ? entry.factors.split(',').filter(s => s.trim() !== "").map(s => BigInt(s.trim())) 
        : [];

    // --- MATCH THE RENDERER'S ZOOM LOGIC ---
    const nearbyFactors = factors.filter(f => f <= 1000n);
    let zoomTargetN = (nearbyFactors.length > 0) 
        ? nearbyFactors[nearbyFactors.length - 1] 
        : p;

    let baseStepSize = (plotType === "binary") 
        ? (canvas.width / 40) 
        : (canvas.width / 2.5) / Number(bigIntSqrt(zoomTargetN || 1n));
    
    let finalStep = baseStepSize * zoom;

    // Get coordinates for the target number
    const pos = coordFn(nBI);
    
    // Calculate new offsets to put the target in the center of the screen
    // We subtract the target's world position from the screen center
    offsetX = (canvas.width / 2) - (Number(pos.x) * finalStep);
    offsetY = (canvas.height / 2) - (Number(pos.y) * finalStep);

    requestAnimationFrame(plotData);
}

function updateStats(type, p, label, Mnum, factors, entry) {
    const statsDiv = document.getElementById('statsDisplay');
    if (!entry) return;

    const getCoordFn = () => {
        switch (type) {
            case "binary": return getBinaryCoords;
            case "ulam": return getSpiralCoordsBigInt;
            case "serpentine": return getSerpentineCoords;
            case "shell": return getShellCoords;
            case "hexagon": return getHexCoords;
            case "mod12": return getMod12Coords;
            default: return getShellCoords;
        }
    };

    const getGeomData = (nBI, index = -1) => {
        let labelText = "";
        switch (type) {
            case "binary": labelText = index === -1 ? `Bits ${entry.binaryBitlen}, Offset ${entry.binaryOffset}` : `Bits ${entry.factorBinaryBitlen[index]}, Offset ${entry.factorBinaryOffset[index]}`; break;
            case "ulam": labelText = index === -1 ? `Shell ${entry.ulamShell}` : `Shell ${entry.factorUlamShell[index]}`; break;
            case "serpentine": labelText = index === -1 ? `Row ${entry.serpentineRow}, Col ${entry.serpentineColumn}` : `Row ${entry.factorSerpentineRow[index]}, Col ${entry.factorSerpentineColumn[index]}`; break;
            case "shell": labelText = index === -1 ? `Row ${entry.squareRow}, Col ${entry.squareCol}` : `Row ${entry.factorSquareRow[index]}, Col ${entry.factorSquareCol[index]}`; break;
            case "hexagon": labelText = index === -1 ? `Shell ${entry.hexagonShell}` : `Shell ${entry.factorHexagonShell[index]}`; break;
            case "mod12": labelText = `Ring ${Math.ceil(Number(nBI) / 12)}, Val ${nBI % 12n}`; break;
        }
        return `<span style="color: #bbb;">${labelText}</span>`;
    };

    const coordFn = getCoordFn();
    let html = `<div style="font-family: monospace; line-height: 1.8; font-size: 14px;">`;
    
    // Number: Red if Prime, Blue if Composite
    const mValueColor = factors.length > 0 ? '#3498db' : '#e74c3c'; 
    html += `<div>
                <span style="color: #bbb;">Number:</span> 
                <b style="color: ${mValueColor}; cursor: pointer;" onclick="jumpToNumber(BigInt('${Mnum}'), ${coordFn.name})">${Mnum}</b><span style="color: #bbb;">,</span> 
                ${getGeomData(Mnum)}
             </div>`;

    // Factors: Always Green
    factors.forEach((f, i) => {
    html += `<div>
                <span style="color: #bbb;">Factor:</span> 
                <b style="color: #00ff88; cursor: pointer;" onclick="jumpToNumber(BigInt('${f}'), ${coordFn.name})">${f}</b><span style="color: #bbb;">,</span> 
                ${getGeomData(f, i)}
             </div>`;
    })

    html += `</div>`;
    statsDiv.innerHTML = html;
}

function playIfShiny(sel) {
    if (sel.options[sel.selectedIndex].text.includes('✨')) {
        const s = document.getElementById('shinySound');
        s.currentTime = 0; s.play().catch(()=>{});
    }
}

window.onload = () => { recenterCamera(); };
</script>
</body>
</html>